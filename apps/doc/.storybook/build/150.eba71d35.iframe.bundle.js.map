{"version":3,"file":"150.eba71d35.iframe.bundle.js","mappings":";AAeA;AAeA;;;;;;AC8GA;ACzGA;AAqEA","sources":["webpack://yith-components-doc/../../packages/components/src/container/Container.tsx","webpack://yith-components-doc/../../packages/components/src/popover/Popover.tsx","webpack://yith-components-doc/../../packages/components/src/icon-button/IconButton.tsx"],"sourcesContent":["import { Breakpoint, styled, SxProps } from '@yith/styles';\nimport React, { forwardRef } from 'react';\n\ntype ContainerProps = React.ComponentProps<'div'> & {\n\tmaxWidth?: false | Breakpoint | number;\n\tsx?: SxProps;\n};\n\ntype ContainerOwnserState = {\n\tmaxWidth: false | Breakpoint | number;\n};\n\ntype StyledContainerProps = { ownerState: ContainerOwnserState };\n\nconst ContainerRoot = styled( 'div', { name: 'Container', slot: 'Root' } )<StyledContainerProps>`\n\t${ ( { ownerState, theme } ) => {\n\tconst { maxWidth } = ownerState;\n\tconst style: any = {};\n\n\tif ( maxWidth !== false ) {\n\t\tif ( typeof maxWidth === 'string' && typeof theme.breakpoints.values[ maxWidth ] !== 'undefined' ) {\n\t\t\tstyle.maxWidth = theme.breakpoints.values[ maxWidth ] + theme.breakpoints.unit;\n\t\t} else {\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\treturn style;\n} }\n`;\n\nconst Container = forwardRef<HTMLDivElement, ContainerProps>( function Container(\n\t{ children, maxWidth = false, ...props },\n\tref\n) {\n\tconst ownerState: ContainerOwnserState = { maxWidth };\n\n\treturn (\n\t\t<ContainerRoot { ...props } ownerState={ ownerState } ref={ ref }>\n\t\t\t{ children }\n\t\t</ContainerRoot>\n\t);\n} );\n\nexport default Container;\n","import { createPortal } from 'react-dom';\nimport React, { useEffect, useLayoutEffect, useRef } from 'react';\nimport { styled } from '@yith/styles';\nimport type { PopoverComputedPosition, PopoverComputePositionProps } from \"./types.internal\";\nimport type { PopoverProps } from \"./types\";\n\nconst PopoverRoot = styled( 'div', { name: 'Popover', slot: 'Root' } )`\n\tposition: fixed;\n\tz-index: 9999999;\n\tdisplay: flex;\n\tflex-direction: column;\n\theight: fit-content;\n`;\n\nconst getAnchorRect = ( anchorRef: HTMLElement ) => {\n\treturn typeof anchorRef?.getBoundingClientRect === 'function' ? anchorRef.getBoundingClientRect() : null;\n};\n\nconst computePopoverPosition = ( {\n\t\t\t\t\t\t\t\t\t anchorRect,\n\t\t\t\t\t\t\t\t\t container,\n\t\t\t\t\t\t\t\t\t position,\n\t\t\t\t\t\t\t\t\t verticalMargin = 0,\n\t\t\t\t\t\t\t\t\t forceMinWidth,\n\t\t\t\t\t\t\t\t\t forceInView = true\n\t\t\t\t\t\t\t\t }: PopoverComputePositionProps ) => {\n\tlet [ yPos, xPos ] = position.split( ' ' );\n\tconst computed: PopoverComputedPosition = {} as PopoverComputedPosition;\n\tconst containerRect = container.getBoundingClientRect();\n\n\tconst { clientWidth: viewportWidth, clientHeight: viewportHeight } = document.documentElement;\n\n\tlet minWidth = 0;\n\n\tif ( true === forceMinWidth ) {\n\t\tminWidth = anchorRect.width;\n\t} else if ( false !== forceMinWidth ) {\n\t\tminWidth = forceMinWidth;\n\t}\n\n\tconst positions = {\n\t\tleft: anchorRect.left,\n\t\tright: viewportWidth - anchorRect.right,\n\t\ttop: anchorRect.top + anchorRect.height + verticalMargin,\n\t\tbottom: viewportHeight - anchorRect.top + verticalMargin,\n\t};\n\n\tconst allowedXPos = [];\n\tif ( positions.left + containerRect.width <= viewportWidth ) {\n\t\tallowedXPos.push( 'left' );\n\t}\n\tif ( positions.right + containerRect.width <= viewportWidth ) {\n\t\tallowedXPos.push( 'right' );\n\t}\n\n\tif ( !allowedXPos.length ) {\n\t\t// Choose the best one.\n\t\tif ( positions.left < positions.right ) {\n\t\t\tallowedXPos.push( 'left' );\n\t\t} else {\n\t\t\tallowedXPos.push( 'right' );\n\t\t}\n\t}\n\n\tconst allowedYPos = [];\n\tif ( positions.top + containerRect.height <= viewportHeight ) {\n\t\tallowedYPos.push( 'bottom' );\n\t}\n\tif ( positions.bottom + containerRect.height <= viewportHeight ) {\n\t\tallowedYPos.push( 'top' );\n\t}\n\n\tif ( !allowedYPos.length ) {\n\t\t// Choose the best one.\n\t\tif ( positions.top < positions.bottom ) {\n\t\t\tallowedYPos.push( 'bottom' );\n\t\t} else {\n\t\t\tallowedYPos.push( 'top' );\n\t\t}\n\t}\n\n\txPos = !allowedXPos.includes( xPos ) ? allowedXPos[ 0 ] : xPos;\n\tyPos = !allowedYPos.includes( yPos ) ? allowedYPos[ 0 ] : yPos;\n\n\tif ( 'left' === xPos ) {\n\t\tcomputed.left = positions.left;\n\t} else {\n\t\tcomputed.right = positions.right;\n\t}\n\n\tif ( 'bottom' === yPos ) {\n\t\tcomputed.top = positions.top;\n\t} else {\n\t\tcomputed.bottom = positions.bottom;\n\t}\n\n\tif ( [ true, 'horizontally' ].includes( forceInView ) ) {\n\t\tcomputed?.left && ( computed.left = Math.max( 0, computed.left ) );\n\t\tcomputed?.right && ( computed.right = Math.max( 0, computed.right ) );\n\n\t\tcomputed.maxWidth = viewportWidth - ( computed?.left ?? computed?.right );\n\t}\n\n\tif ( [ true, 'vertically' ].includes( forceInView ) ) {\n\t\tcomputed?.top && ( computed.top = Math.max( 0, computed.top ) );\n\t\tcomputed?.bottom && ( computed.bottom = Math.max( 0, computed.bottom ) );\n\n\t\tcomputed.maxHeight = viewportHeight - ( computed?.top ?? computed?.bottom );\n\t}\n\n\tif ( minWidth ) {\n\t\tcomputed.minWidth = minWidth;\n\n\t\tif ( typeof computed.maxWidth !== 'undefined' ) {\n\t\t\tcomputed.minWidth = Math.min( computed.minWidth, computed.maxWidth );\n\t\t}\n\t}\n\n\tcomputed.xPos = 'left' in computed ? 'left' : 'right';\n\tcomputed.yPos = 'top' in computed ? 'bottom' : 'top';\n\n\tconst { offsetParent } = container;\n\n\t/**\n\t * If there is a positioned ancestor element that is not the body,\n\t * subtract the position from the anchor rect.\n\t * Useful in case of disabling the Portal.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n\t */\n\tif ( offsetParent && offsetParent !== document.body ) {\n\t\tconst offsetParentRect = offsetParent.getBoundingClientRect();\n\t\ttypeof computed.left !== 'undefined' && ( computed.left -= offsetParentRect.left );\n\t\ttypeof computed.right !== 'undefined' && ( computed.right -= viewportWidth - offsetParentRect.right );\n\t\ttypeof computed.top !== 'undefined' && ( computed.top -= offsetParentRect.top );\n\t\ttypeof computed.bottom !== 'undefined' && ( computed.bottom -= viewportHeight - offsetParentRect.bottom );\n\t}\n\n\treturn computed;\n};\n\nconst cssSize = ( size?: number | string ) => {\n\tif ( size === undefined ) {\n\t\treturn '';\n\t}\n\treturn typeof size === 'string' ? size : `${ size }px`;\n};\n\nconst setStyles = ( element: HTMLElement, styles: React.CSSProperties ) => {\n\tObject.assign( element.style, styles );\n};\n\nfunction setAttribute( element: HTMLElement, prop: string, value: string ) {\n\tif ( !value ) {\n\t\tif ( element.hasAttribute( prop ) ) {\n\t\t\telement.removeAttribute( prop );\n\t\t}\n\t} else if ( element.getAttribute( prop ) !== value ) {\n\t\telement.setAttribute( prop, value );\n\t}\n}\n\nfunction Popover(\n\t{\n\t\tanchorRef,\n\t\tposition = 'bottom left',\n\t\tchildren,\n\t\tverticalMargin = 0,\n\t\tonClickOutside,\n\t\tforceMinWidth = false,\n\t\tdisablePortal = false,\n\t\tforceInView = true,\n\t\t...other\n\t}: PopoverProps\n) {\n\tconst containerRef = useRef<HTMLDivElement>( null );\n\tconst syntheticEventRef = useRef( false );\n\n\t// Keep track of click events that bubbled up through the portal.\n\tconst handleSynthetic = () => {\n\t\tsyntheticEventRef.current = true;\n\t};\n\n\tuseLayoutEffect( () => {\n\t\tif ( !containerRef.current || !anchorRef ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst refresh = () => {\n\t\t\tconst container = containerRef.current;\n\t\t\tconst anchorRect = getAnchorRect( anchorRef );\n\n\t\t\tif ( container && anchorRect ) {\n\t\t\t\tconst popoverPosition = computePopoverPosition( {\n\t\t\t\t\tanchorRect,\n\t\t\t\t\tcontainer,\n\t\t\t\t\tposition,\n\t\t\t\t\tverticalMargin,\n\t\t\t\t\tforceMinWidth,\n\t\t\t\t\tforceInView\n\t\t\t\t} );\n\n\t\t\t\tsetStyles(\n\t\t\t\t\tcontainer,\n\t\t\t\t\t{\n\t\t\t\t\t\tleft: cssSize( popoverPosition.left ),\n\t\t\t\t\t\tright: cssSize( popoverPosition.right ),\n\t\t\t\t\t\ttop: cssSize( popoverPosition.top ),\n\t\t\t\t\t\tbottom: cssSize( popoverPosition.bottom ),\n\t\t\t\t\t\tmaxWidth: cssSize( popoverPosition.maxWidth ),\n\t\t\t\t\t\tmaxHeight: cssSize( popoverPosition.maxHeight ),\n\t\t\t\t\t\tminWidth: cssSize( popoverPosition.minWidth ),\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tsetAttribute( container, 'data-x-pos', popoverPosition.xPos );\n\t\t\t\tsetAttribute( container, 'data-y-pos', popoverPosition.yPos );\n\t\t\t}\n\t\t};\n\n\t\trefresh();\n\n\t\t/**\n\t\t * It's useful refreshing position with some interval,\n\t\t * since there are something that can skip at resize/scroll events.\n\t\t * So, we can refresh position each 0.5 seconds.\n\t\t */\n\t\tconst refreshInterval = setInterval( refresh, 500 );\n\n\t\twindow.addEventListener( 'resize', refresh );\n\t\twindow.addEventListener( 'scroll', refresh, true );\n\n\t\treturn () => {\n\t\t\t!!refreshInterval && clearInterval( refreshInterval );\n\n\t\t\twindow.removeEventListener( 'resize', refresh );\n\t\t\twindow.removeEventListener( 'scroll', refresh );\n\t\t};\n\t}, [ anchorRef ] );\n\n\tconst handleClickOutside = ( event: MouseEvent ) => {\n\t\tif ( containerRef?.current && event?.target ) {\n\t\t\t// The container MUST exist.\n\t\t\tconst theTarget = event.target as HTMLElement;\n\t\t\tconst isContainerClick = containerRef.current.contains( theTarget );\n\t\t\tconst isAnchorClick = anchorRef && anchorRef.contains( theTarget );\n\t\t\tconst isInsideReactTree = syntheticEventRef.current;\n\t\t\tsyntheticEventRef.current = false;\n\n\t\t\tif ( !isContainerClick && !isAnchorClick && !isInsideReactTree ) {\n\t\t\t\tonClickOutside?.( event );\n\t\t\t}\n\t\t}\n\t};\n\n\tuseEffect( () => {\n\t\tdocument.addEventListener( 'mousedown', handleClickOutside );\n\t\treturn () => {\n\t\t\tdocument.removeEventListener( 'mousedown', handleClickOutside );\n\t\t\tsyntheticEventRef.current = false;\n\t\t};\n\t} );\n\n\tconst popover = (\n\t\t<PopoverRoot role=\"presentation\" { ...other } ref={ containerRef } onMouseDown={ handleSynthetic }>\n\t\t\t{ children }\n\t\t</PopoverRoot>\n\t);\n\n\treturn disablePortal ? popover : createPortal( popover, document.body );\n}\n\nexport default Popover;\n","import { alpha, FieldSize, PaletteClass, styled, SxProps } from '@yith/styles';\nimport React, { forwardRef } from 'react';\n\ntype IconButtonOwnerState = {\n\t/**\n\t * The color of the icon button.\n\t */\n\tcolor: 'default' | 'inherit' | PaletteClass;\n\t/**\n\t * Set the variant to change the style of the icon button.\n\t */\n\tvariant: 'ghost' | 'shadowed';\n\t/**\n\t * The size.\n\t */\n\tsize: FieldSize;\n\t/**\n\t * The font size.\n\t */\n\tfontSize?: FieldSize | React.CSSProperties['fontSize'];\n\t/**\n\t * Sx props.\n\t */\n\tsx?: SxProps\n}\n\ntype IconButtonOwnProps = Partial<IconButtonOwnerState>;\ntype IconButtonPropsWithRef = Omit<React.ComponentProps<'button'>, keyof IconButtonOwnProps> & IconButtonOwnProps;\ntype IconButtonProps = Omit<IconButtonPropsWithRef, 'ref'>;\n\ntype StyledIconButtonProps = {\n\townerState: IconButtonOwnerState;\n};\n\nconst IconButtonRoot = styled( 'button', { name: 'IconButton', slot: 'Root' } )<StyledIconButtonProps>`\n\t${ ( { ownerState, theme } ) => {\n\tconst { color, variant, size } = ownerState;\n\n\tlet mainColor = theme.palette.action.active;\n\tif ( color !== 'default' && color !== 'inherit' ) {\n\t\tmainColor = theme.palette[ color ].main;\n\t}\n\n\tconst padding = {\n\t\tsm: 9,\n\t\tmd: 12,\n\t\tlg: 15,\n\t\txl: 18,\n\t}[ size ];\n\n\n\tconst fontSizeMapping = {\n\t\tsm: 14,\n\t\tmd: 16,\n\t\tlg: 18,\n\t\txl: 20,\n\t};\n\tconst fontSize = fontSizeMapping[ ownerState.fontSize as FieldSize ] ?? ownerState.fontSize ?? fontSizeMapping[ size ];\n\n\treturn {\n\t\ttextAlign: 'center',\n\t\tflex: '0 0 auto',\n\t\tfontSize: fontSize,\n\t\tpadding: padding,\n\t\tborder: 0,\n\t\tborderRadius: '50%',\n\t\tcursor: 'pointer',\n\t\tlineHeight: 0,\n\t\tcolor: 'inherit' !== color ? mainColor : color,\n\t\tbackground: 'transparent',\n\t\tboxShadow: `0 0 0 8px ${ alpha( mainColor, 0 ) }`,\n\t\ttransition: 'background .3s ease-in-out, box-shadow .3s ease-in-out',\n\t\t'&:disabled': {\n\t\t\tpointerEvents: 'none',\n\t\t\topacity: theme.palette.action.disabledOpacity\n\t\t},\n\t\t...( variant === 'ghost' && {\n\t\t\t'&:hover': {\n\t\t\t\tbackground: alpha( mainColor, theme.palette.action.hoverOpacity ),\n\t\t\t\tboxShadow: `0 0 0 0px ${ alpha( mainColor, theme.palette.action.hoverOpacity ) }`,\n\t\t\t},\n\t\t\t'&:focus-visible': {\n\t\t\t\tborder: 0,\n\t\t\t\toutline: 0,\n\t\t\t\tboxShadow: '0 0 0 3px ' + alpha( mainColor, theme.palette.action.focusOpacity ),\n\t\t\t},\n\t\t} ),\n\t\t...( variant === 'shadowed' && {\n\t\t\tbackground: theme.palette.background.default,\n\t\t\tboxShadow: `0 2px 7px 0 rgba(170,198,222, .5)`,\n\t\t\t'&:hover': {\n\t\t\t\tboxShadow: `0 3px 10px 0 rgba(170,198,222, .6)`,\n\t\t\t},\n\t\t\t'&:focus-visible': {\n\t\t\t\tborder: 0,\n\t\t\t\toutline: 0,\n\t\t\t\tboxShadow: '0 3px 12px 0 rgba(170,198,222, .6), 0 0 0 3px rgba(170,198,222, .2)',\n\t\t\t},\n\t\t} ),\n\n\t};\n} }\n`;\n\nconst IconButton = forwardRef<HTMLButtonElement, IconButtonProps>( function IconButton(\n\t{\n\t\ttype = 'button',\n\t\tcolor = 'default',\n\t\tvariant = 'ghost',\n\t\tsize = 'md',\n\t\tfontSize,\n\t\tchildren,\n\t\t...other\n\t},\n\tref ) {\n\tconst ownerState: IconButtonOwnerState = { color, variant, size, fontSize };\n\treturn (\n\t\t<IconButtonRoot type={ type } ref={ ref } ownerState={ ownerState } { ...other }>\n\t\t\t{ children }\n\t\t</IconButtonRoot>\n\t);\n} );\n\nexport default IconButton;\n"],"names":[],"sourceRoot":""}